
## Table of Contents
 - [Inventory](#inventory)
 - [Folder structure](#folder-structure)
   - [Fuel](#fuel)
   - [Nodes](#nodes)
 - [Tasks](#tasks)
   - [apt_update.yml](#apt_updateyml)
   - [get_current_mu.yml](#get_current_muyml)
   - [verify_md5.yml](#verify_md5yml)
   - [clean_customizations.yml](#clean_customizationsyml)
   - [gather_current_customizations.yml](#gather_current_customizationsyml)
   - [verify_patches.yml](#verify_patchesyml)
   - [apt_upgrade.yml](#apt_upgradeyml)
   - [apply_patches.yml](#apply_patchesyml)
   - [rollback_upgrade.yml](#rollback_upgradeyml)
 - [Playbooks](#playbooks)
   - [gather_customizations.yml](#gather_customizationsyml)
   - [verify_patches.yml](#verify_patchesyml)
   - [apply_mu.yml](#apply_patchesyml)
   - [restart_services.yml](#restart_servicesyml)
   - [rollback.yml](#rollbackyml)


Inventory
=========

Inventory Python script generates inventory data for Ansible using Fuel API.
For review inventory you can run this script separately.

[fuel_inventory.py](../inventory/fuel_inventory.py)

Folder structure
================

By default it looks like this (might be configured in conf file):

Fuel
----

Variables in config:
```
fuel_dir:         "/root/fuel_mos_mu"
fuel_custom_dir:  "{{ fuel_dir }}/customizations"
fuel_patches_dir: "{{ fuel_dir }}/patches"
```

Directory tree:
```
../fuel_mos_mu/
└── env_1
    ├── customizations
    │   ├── node-1
    │   │   ├── neutron-common_customization.patch
    │   │   └── nova-compute_customization.patch
    │   ├── node-2
    │   ├── node-3
    │   │   └── neutron-common_customization.patch
    │   ├── node-4
    │   └── node-5
    ├── customizations_backup
    │   └── customizations__09.27.16__03-39-12.tgz
    ├── customizations_unified
    │   ├── neutron-common_customization.patch
    │   └── nova-compute_customization.patch
    ├── customizations_verification
    │   ├── neutron-common
    │   │   ├── node-1
    │   │   │   └── neutron-common_customization.patch
    │   │   └── node-3
    │   │       └── neutron-common_customization.patch
    │   └── nova-compute
    │       └── node-1
    │           └── nova-compute_customization.patch
    └── patches
        ├── 00-customizations
        │   ├── neutron-common_customization.patch
        │   └── nova-compute_customization.patch
        └── 01-neutron.patch
```
* Each env has its own folder **<env_id>**

* **customizations** is used for gathering customizations from nodes.
  Customizations are placed in folder with nodename.
  Customizations are gathered when this folder is absent or if you want to
  gather it from scratch please use flag **gather_customizations: true**.
  This folder is generated by [gather_customizations.yml](../tasks/gather_customizations.yml)

* **customizations_backup** contains backups of customizations.
  Backup is generated after gathering customizations.

* **customizations_verifications** is used for processing of customizations
  which contains set of folders (package customization) across the enviroment.
  This folder is generated by [verify_customizations.yml](../tasks/verify_customizations.yml)

* **customizations_unified** contains unified customizations which
  will be copied to **patches/00-customizations** folde and  used for applying after updating.

* Folder **patches** is used for storing set of patches which will be synced
  on nodes and used for verifying and applying on cloud.
  Patches should have **.patch** extensions. Please be aware that patches
  will be applied in alphabetic order, also keep in mind that if flag
  **use_current_customizations: true** is enabled current customizations
  will be also copied to **patches** folder on nodes with to
  **00-customizations** folder.
  So it is recommended to name patches with prefixes like this
  **01-\<patchname\>.patch, 02-\<patchname2\>.patch**.

Nodes
-----

Direrctory tree:
```
/root/mos_mu/
├── apt
│   ├── apt.conf
│   ├── preferences.d
│   │   └── mos.pref
│   └── sources.list.d
│       ├── fuel.list
│       ├── GA.list
│       ├── mu-1.list
│       ├── mu-2.list
│       └── mu-3.list
├── customizations
│   ├── neutron-common
│   │   ├── 2%3a7.1.1-4~u14.04+mos82
│   │   │   └── ...
│   │   └── neutron-common_customization.patch
│   └── nova-compute
│       ├── 2%3a12.0.4-1~u14.04+mos10
│       │   └── ...
│       └── nova-compute_customization.patch
├── patches
│   ├── 00-customizations
│   │   ├── neutron-common_customization.patch
│   │   └── nova-compute_customization.patch
│   └── 01-neutron.patch
└── verification
    ├── neutron-common
    │   ├── 2%3a7.1.1-4~u14.04+mos82
    │   │   ├── neutron-common_2%3a7.1.1-4~u14.04+mos82_all.deb
    │   │   └── ...
    │   └── neutron-common_customization.patch
    ├── nova-compute
    │   ├── 2%3a12.0.4-1~u14.04+mos10
    │   │   ├── nova-compute_2%3a12.0.4-1~u14.04+mos10_all.deb
    │   │   └── ...
    │   └── nova-compute_customization.patch
    └── python-neutron
        ├── 01-neutron.patch
        └── 2%3a7.1.1-4~u14.04+mos82
            ├── python-neutron_2%3a7.1.1-4~u14.04+mos82_all.deb
            └── ...
```

* Folder **apt** contains apt.conf which is always used for apt and uses
  only **sources.lists.d** folder for sources lists.

* **apt/sources.list.d** contains sources lists for all configured in config
  repositories.

* **apt/preferences.d** contains preferences for packages pinning.

* **customizations** folder consists of folders for customized packages.
  Packages folder contains folder (current package version) with unpacked
  package and diff file between this unpacked version and current installed
  (customized) version.

* **patches** folder contains all patches from Fuel **patches** folder and
  current customizations **00-customizations** if flag
  **use_current_customizations: true** is enabled. This folder is cleared every
  time when task [verify_patches.yml](#verify_patchesyml) is started.

* **verification** folder consists of folders for customized packages.
  Packages folder contains folder (candidate package version, by default,
  configured by flag **pkg_ver_for_verifiacation: "Candidate"**) with unpacked
  package and patches files witch should be applied.


Tasks
=====

[apt_update.yml](../playbooks/tasks/apt_update.yml)
---------------------------------------------------


* Clean **apt** folder on nodes.
* Generate and copy on nodes sources.list files from
  [templates/sources.list.j2](../playbooks/templates/sources.list.j2) using i
  configuring repositories in conf file.
* Generate and copy on nodes **apt.conf** file from
  [templates/apt_conf.j2](../playbooks/templates/apt.conf.j2).
* Perform APT update using generated **apt.conf** on nodes.

[get_current_mu.yml](../playbooks/tasks/get_current_mu.yml)
-----------------------------------------------------------

* Run [files/get_current_mu.sh](../playbooks/files/get_current_mu.sh) script to
  identify which MU currently is applied. Actually this script just uses one by
  one sources.list from sources.list.d folder and check if any package have
  available 'update'.  If noone have update it means that exactly this MU is
  installed now. It can return 'undefine' result, that means the node has
  installed packages from different MU(or other undefined) repos.

[verify_md5.yml](../playbooks/tasks/verify_md5.yml)
---------------------------------------------------

* Run [files/verify_packages_ubuntu.sh](../playbooks/files/verify_packages_ubuntu.sh)
  script which for all installed python packages calculate MD5 sum and compared
  with origin.
* Return list of customized packages in **md5_verify_result** variable.

[clean_customizations.yml](../playbooks/tasks/clean_customizations.yml)
-----------------------------------------------------------------------

* Delete **customizations** folder on Fuel.
* Delete **customizations** folder on nodes.

[gather_customizations.yml](../playbooks/tasks/gather_customizations.yml)
-------------------------------------------------------------------------

* Check if customizations are already gathered ( **customization** folder exits
  on nodes ).
* Create **customizations** folder if doesn't exist.
* If doesn't exist for each customized package in **md5_verify_result** run s
  [files/get_package_customizations.sh](../playbooks/files/get_package_customizations.sh).
  This script unpacks cached origin installed package (or download if cached does
  not exist) and make a diff between origin and current state.
* If customizations were gathered, download them on Fuel in
  **customizations/\<nodename\>**.

[verify_patches.yml](../playbooks/tasks/verify_patches.yml)
-----------------------------------------------------------

* Clean **patches** folder on nodes.
* Clean **verification** folder on nodes.
* Copy patches from Fuel folder **patches** to nodes folder **patches**
  (if **rollback** is not enabled).
* Run [files/use_customizations.sh](../playbooks/files/use_customizations.sh)
  script which copy current patches from **customizations** folder to
  **patches** folder (if **use_curret_customization** is enabled).
* Run [files/verify_patches.sh](../playbooks/files/verify_patches.sh) script
  which:
    * Make sure that each patch affects only one package.
    * Download and extract candidate package if it does not already exist.
    * Try to apply patch. If more than 1 patch affects this package they will
      be applied in alphabetic order.

[apt_upgrade.yml](../playbooks/tasks/apt_upgrade.yml)
-----------------------------------------------------

* Correct dependencies.
* Perform APT upgrade.
* Reinstall customized packages

[apply_patches.yml](../playbooks/tasks/apply_patches.yml)
---------------------------------------------------------

* Run [files/apply_patches.sh](../playbooks/files/apply_patches.sh) script
  which just applies sorted by relative name patches in **patches** folder on
  nodes.

[rollback_upgrade.yml](../playbooks/tasks/rollback_upgrade.yml)
---------------------------------------------------------------

* Correct dependencies.
* Perform APT upgrade using only specified in variable **rollback** MU name.
* Reinstall customized packages

Playbooks
=========

By default all playbooks are defined for all nodes except Fuel.
It might be run for any node and group of nodes using standard flag **--limit**
like this `--limit=cluster_2:compute` (all computes in cluster_2).

All playbooks include variable file
[vars/mos_releases/{{ mos_release }}.yml](../playbooks/vars/mos_releases)
based on **mos_release** variable, which dynamically defined during
the inventarization phase.

Also it is possible to pass extra variables via cli using standard flag **-e**,
like this `-e '{"apt_update":false, "verify_md5":true}'`.

[gather_customizations.yml](../playbooks/gather_customizations.yml)
-------------------------------------------------------------------

Makes sure that customizations were not gathered already and then gathers them.
If you need to gather it again you can use flag **clean_customizations**.

Runs the set of tasks based on set of flags which allow or deny executing some
tasks. Uses
[vars/steps/gather_customizations.yml](../playbooks/vars/steps/gather_customizations.yml)
set of flags.

Run the following tasks:
* [apt_update.yml](#apt_updateyml)
* [get_current_mu.yml](#get_current_muyml)
* [verify_md5.yml](#verify_md5yml)
* [clean_customizations.yml](#clean_customizationsyml)
* [gather_customizations.yml](#clean_customizationsyml)

[verify_patches.yml](../playbooks/verify_patches.yml)
-----------------------------------------------------

Just verify applying patches on target version of packages
**pkg_ver_for_verifiacation**.

Uses [vars/steps/verify_patches.yml](../playbooks/vars/steps/verify_patches.yml)
set of flags.

Runs only two steps:
* [apt_update.yml](../playbooks/tasks/apt_update.yml)
* [verify_patches.yml](../playbooks/tasks/verify_patches.yml)

[apply_mu.yml](../playbooks/apply_mu.yml)
-----------------------------------------

Apply MU, apply patches and re-apply current customizations(if enabled).

By default uses [var/steps/apply_mu.yml](../playbooks/vars/steps/apply_mu.yml)
set of flags.

Run the following tasks:
* [apt_update.yml](#apt_updateyml)
* [get_current_mu.yml](#get_current_muyml)
* [verify_md5.yml](#verify_md5yml)
* [clean_customizations.yml](#clean_customizationsyml)
* [gather_customizations.yml](#gather_customizationsyml)
* [verify_patches.yml](#verify_patchesyml)
* [apt_upgrade.yml](#apt_upgradeyml)
* [apply_patches.yml](#apply_patchesyml)

and then include one more playbook:
* [restart_services.yml](#restart_servicesyml)

[restart_services.yml](../playbooks/restart_services.yml)
---------------------------------------------------------

Restart all services for each role specified in
[vars/mos_releases/{{ mos_releases }}.yml](../playbooks/vars/mos_releases).

Might be used separately.

[rollback.yml](../playbooks/rollback.yml)
-----------------------------------------

This is pseudo rollback, since it does not save the current state, but provide
you a mechanism for install any MU release (that you have initially for
rollback) and apply gathered customizations, of course as usual with verifying
patches before installing.

Runs the following tasks:
* [apt_update.yml](#apt_updateyml)
* [verify_md5.yml](#verify_md5yml)
* [clean_customizations.yml](#clean_customizationsyml)
* [gather_customizations.yml](#gather_customizationsyml)
* [verify_patches.yml](#verify_patchesyml)
* [apt_upgrade.yml](#apt_upgradeyml)
* [apply_patches.yml](#apply_patchesyml)

and then include one more playbook:
* [restart_services.yml](#restart_servicesyml)

Uses [vars/steps/rollback.yml](../playbooks/vars/steps/rollback.yml) set of
flags.
